"""
This module consists of the Different States of the Multi-Agent System.

It can contain States of Specific Agent, or the Overall State of the Multi-Agent System or the Orchestration State of the Multi-Agent System.
This is used to maintain the state of the Multi-Agent System and the agents in the system.

# Purpose of this module:
- To define the states used by various agents in the application.
- To provide a centralized location for managing states, making it easier to update and maintain them.
- To maintain consistency, modularity, and reusability of states across different agents.


"""




from typing import Dict, List, Optional, TypedDict, Literal, Any,Annotated, Sequence
from pydantic import BaseModel, Field, field_validator
from datetime import datetime
from uuid import UUID, uuid4
from langchain_core.messages import BaseMessage
from langgraph.graph.message import add_messages
import operator


# Add more States as needed for the Multi-Agent System.

class AgentState(BaseModel):
    """
    Represents the State of the Multi-Agent System.
    It contains the State of the Multi-Agent System.
    
    """
    
    
    messages: Annotated[Sequence[BaseMessage], add_messages]
    refined_query: str
    #There can be many more fields in the future.


class UserCollectedData(BaseModel):
    """
    Represents the data collected from the user during HITL interactions.
    
    This includes all information gathered through the conversation
    for dashboard generation.
    """
    
    user_persona: Optional[str] = None
    products: List[str] = Field(default_factory=list)
    location: Optional[str] = None
    channels: List[str] = Field(default_factory=list)
    goals: List[str] = Field(default_factory=list)
    time_period: Optional[str] = None
    additional_notes: Optional[str] = None
    brand: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "user_persona": self.user_persona,
            "products": self.products,
            "location": self.location,
            "channels": self.channels,
            "goals": self.goals,
            "time_period": self.time_period,
            "additional_notes": self.additional_notes,
            "brand": self.brand
        }
    
    def is_complete(self) -> bool:
        """Check if all required data has been collected."""
        required_fields = ["products", "channels", "goals", "time_period"]
        return all(getattr(self, field) for field in required_fields)


class QueryRefinementData(BaseModel):
    """
    Represents refined query data from the Query Refiner Agent.
    """
    
    original_query: str
    refined_query: str
    suggested_filters: List[Dict[str, Any]] = Field(default_factory=list)
    suggested_themes: List[Dict[str, Any]] = Field(default_factory=list)
    missing_information: List[str] = Field(default_factory=list)
    confidence_score: float = 0.0


class BooleanQueryData(BaseModel):
    """
    Represents boolean keyword query data generated by the Query Generator Agent.
    """
    
    boolean_query: str
    query_components: List[str] = Field(default_factory=list)
    target_channels: List[str] = Field(default_factory=list)
    filters_applied: Dict[str, Any] = Field(default_factory=dict)
    estimated_results: Optional[int] = None


class ThemeData(BaseModel):
    """
    Represents a theme/category identified by the Data Analyzer Agent.
    """
    
    name: str
    description: str
    boolean_keyword_query: str
    relevance_score: float
    data_count: int
    keywords: List[str] = Field(default_factory=list)
    sentiment_distribution: Optional[Dict[str, float]] = None


class DashboardState(BaseModel):
    """
    Enhanced state for the complete dashboard generation workflow.
    
    This state tracks the entire process from user input to dashboard generation.
    """
    
    # Core message handling
    messages: List[BaseMessage] = Field(default_factory=list)
    
    # Conversation tracking
    conversation_id: str = Field(default_factory=lambda: str(uuid4()))
    current_stage: str = "initial"  # initial, collecting, refining, querying, analyzing, complete
    current_step: str = "initializing"  # For workflow tracking
    workflow_status: str = "started"  # started, in_progress, completed, failed
    timestamp: Optional[datetime] = Field(default_factory=datetime.now)  # Processing timestamp
    
    # Error handling
    errors: List[str] = Field(default_factory=list)
    
    # User data collection
    user_data: UserCollectedData = Field(default_factory=UserCollectedData)
    user_query: str = ""  # Original user query
    user_context: Dict[str, Any] = Field(default_factory=dict)  # Additional user context
    
    # Query processing
    original_query: str = ""
    query_refinement: Optional[QueryRefinementData] = None
    query_refinement_data: Optional[QueryRefinementData] = None  # Alias for compatibility
    boolean_query: Optional[BooleanQueryData] = None
    boolean_query_data: Optional[BooleanQueryData] = None  # Alias for compatibility
    query_generation_data: Optional[BooleanQueryData] = None  # Another alias
    
    # Data processing
    fetched_data: List[Dict[str, Any]] = Field(default_factory=list)
    identified_themes: List[ThemeData] = Field(default_factory=list)
    theme_data: Optional[Dict[str, Any]] = None  # Processed theme data
    
    # User data collection tracking
    user_collected_data: Optional[UserCollectedData] = None
    
    # HITL tracking
    pending_questions: List[str] = Field(default_factory=list)
    user_confirmations: Dict[str, bool] = Field(default_factory=dict)
    hitl_verification_data: Optional[Dict[str, Any]] = None  # HITL verification state
    
    # Context and metadata
    rag_context: Dict[str, Any] = Field(default_factory=dict)
    processing_metadata: Dict[str, Any] = Field(default_factory=dict)
    
    # Final output
    dashboard_config: Optional[Dict[str, Any]] = None
    
    class Config:
        arbitrary_types_allowed = True
    
    def add_message(self, message: BaseMessage):
        """Add a message to the conversation."""
        self.messages.append(message)
    
    def update_user_data(self, **kwargs):
        """Update user collected data."""
        for key, value in kwargs.items():
            if hasattr(self.user_data, key):
                setattr(self.user_data, key, value)
    
    def add_pending_question(self, question: str):
        """Add a question that needs user response."""
        self.pending_questions.append(question)
    
    def clear_pending_questions(self):
        """Clear all pending questions."""
        self.pending_questions.clear()
    
    def is_ready_for_next_stage(self) -> bool:
        """Check if state is ready to move to next processing stage."""
        stage_requirements = {
            "initial": lambda: bool(self.original_query),
            "collecting": lambda: self.user_data.is_complete(),
            "refining": lambda: bool(self.query_refinement),
            "querying": lambda: bool(self.boolean_query),
            "analyzing": lambda: bool(self.fetched_data),
            "complete": lambda: bool(self.dashboard_config)
        }
        
        return stage_requirements.get(self.current_stage, lambda: False)()
    
    def get_summary(self) -> Dict[str, Any]:
        """Get a summary of the current state for display."""
        return {
            "conversation_id": self.conversation_id,
            "current_stage": self.current_stage,
            "user_data": self.user_data.to_dict(),
            "pending_questions": self.pending_questions,
            "themes_count": len(self.identified_themes),
            "is_complete": self.current_stage == "complete"
        }


class HITLState(BaseModel):
    """
    State specific to Human-in-the-Loop verification processes.
    """
    
    verification_type: str  # "data_collection", "query_confirmation", "theme_approval"
    data_to_verify: Dict[str, Any]
    user_response: Optional[str] = None
    verification_status: str = "pending"  # pending, approved, rejected, modified
    feedback: Optional[str] = None
    
    
class WorkflowState(TypedDict):
    """
    TypedDict version for LangGraph compatibility.
    
    This is used by the LangGraph workflow system for state management.
    """
    
    # Core fields that LangGraph needs
    messages: Annotated[Sequence[BaseMessage], add_messages]
    
    # Dashboard-specific state
    dashboard_state: DashboardState
    
    # Current processing context
    current_agent: str
    next_action: str
    
    # Error handling
    error_message: Optional[str]
    retry_count: int
